---
layout: post
title:  "Mysql内容"
---
知识点来源于《mysql技术内幕:  innodb引擎》和极客时间的《Mysql 45讲》
## 单进程多线程
master thread : 保证数据一致性  
IO thread : 处理AIO中的IO回调  
purge thread : 回收并再分配undo页  
page cleaner thread : 刷新脏页，减少master的负担 
## 内存
innodb将记录按页进行存储在磁盘上。使用**缓冲池**弥补速度差距  
缓冲池中包括 : 索引页 数据页 undo页 插入缓存 自适应哈希索引 锁信息 数据字典信息等
## innodb特性
### 插入缓存
**适用于**非唯一的辅助索引  
插入页若在缓冲池中则直接插入否则插入到一个插入缓存对象中  
数据结构是一颗**B+树**，非叶结点包括9字节，三部分内容，4字节space记录表的唯一id，1字节marker用来兼容旧版本的插入缓存，4字节offset表示页所在的偏移量，构成了search key亦即键值，叶节点除了键值外还包括4字节metadata，储存有关记录的数据，最后是13字节实际插入记录的字段。同时使用bitmap记录每个辅助索引页的可用空间。  
三种情况合并插入缓存:
1. 辅助索引页被读取到缓冲池
2. bitmap显示辅助索引页无可用空间
3. master thread(固定时间进行合并)

### 两次写
提供数据页的可靠性。  
应对部分写失效，提供数据页副本。  
分为两部分:内存中的重写缓存和磁盘上共享表空间的连续的128页，两者大小相同的2MB。
写入步骤是:首先将脏页复制到缓存，然后分两次每次1MB写入磁盘地区，再调用fsync函数同步磁盘。崩溃时可以使用缓存中的数据重置数据页之后完成redo。
### 自适应哈希索引(Adaptive Hash Index,AHI)
**自动**为可能带来性能提升的数据建立哈希索引。
添加的条件:
1. 对页的连续访问模式一致,即类似于'where a = 1'和'where a = 1 and b = 2'，访问模式指的是查询条件
2. 以此模式访问了100次
3. 页通过该模式访问了N次(N=页中记录/16)

### 异步IO
IO的并发或者将多个读取连续内存的IO合并
### 刷新邻接页
刷新脏页时会检测邻接页，若是脏页一并刷新，减少IO次数  

## 索引与算法
innodb支持三种索引 : B+树索引 哈希索引 全文索引
> B+树中的B代表balance

B+树索引只是查找数据所在的页，读取页后再进行查找。  
插入 : B+树子节点满的时候，并不一定会拆分，考虑到拆分的开销，如果左右节点并不慢，会进行旋转，直观点就是数据平移以放下新的数据。   
删除 : 使用填充因子(>=0.5),节点填充度如果小于填充因子进行相应合并  
&nbsp;  
聚集索引和辅助索引.  
聚集索引 : 聚集索引表记录的排列顺序和索引的排列顺序一致,叶子节点中存储的就是行数据，行数据在物理储器中的真实地址就是按照主键索引树形成的顺序进行排列的，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放.因为在物理内存中的顺序只能有一种，所以聚集索引在一个表中只能有一个。  
辅助索引 : 非聚集索引制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致（在逻辑上数据是按顺序排存放的，但是物理上在真实的存储器中是散列存放的），两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。  
辅助索引先根据索引找到主键再根据主键到聚集索引里查询数据。  
B+树的分裂 : 考虑一个自增的索引，此种情况下分裂左侧的子节点会有空间浪费，新数据只会插入右边。为了改善此种情况，innoDB决定若往同一方向进行分裂的数量为5，且此时定位的记录(将插入的记录的前一个节点)后还有三个节点，则将定位后移3，自增索引往往分裂右边只有新插入记录。