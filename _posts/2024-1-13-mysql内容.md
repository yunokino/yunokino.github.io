---
layout: post
title:  "Mysql内容"
---
知识点来源于《高性能MySQL》《mysql技术内幕:  innodb引擎》和极客时间的《Mysql 45讲》
## 单进程多线程
master thread : 保证数据一致性  
IO thread : 处理AIO中的IO回调  
purge thread : 回收并再分配undo页  
page cleaner thread : 刷新脏页，减少master的负担 
## 内存
innodb将记录按页进行存储在磁盘上。使用**缓冲池**弥补速度差距  
缓冲池中包括 : 索引页 数据页 undo页 插入缓存 自适应哈希索引 锁信息 数据字典信息等
## innodb特性
### 插入缓存
**适用于**非唯一的辅助索引  
插入页若在缓冲池中则直接插入否则插入到一个插入缓存对象中  
数据结构是一颗**B+树**，非叶结点包括9字节，三部分内容，4字节space记录表的唯一id，1字节marker用来兼容旧版本的插入缓存，4字节offset表示页所在的偏移量，构成了search key亦即键值，叶节点除了键值外还包括4字节metadata，储存有关记录的数据，最后是13字节实际插入记录的字段。同时使用bitmap记录每个辅助索引页的可用空间。  
三种情况合并插入缓存:
1. 辅助索引页被读取到缓冲池
2. bitmap显示辅助索引页无可用空间
3. master thread(固定时间进行合并)

### 两次写
提供数据页的可靠性。  
应对部分写失效，提供数据页副本。  
分为两部分:内存中的重写缓存和磁盘上共享表空间的连续的128页，两者大小相同的2MB。
写入步骤是:首先将脏页复制到缓存，然后分两次每次1MB写入磁盘地区，再调用fsync函数同步磁盘。崩溃时可以使用缓存中的数据重置数据页之后完成redo。
### 自适应哈希索引(Adaptive Hash Index,AHI)
**自动**为可能带来性能提升的数据建立哈希索引。
添加的条件:
1. 对页的连续访问模式一致,即类似于'where a = 1'和'where a = 1 and b = 2'，访问模式指的是查询条件
2. 以此模式访问了100次
3. 页通过该模式访问了N次(N=页中记录/16)

### 异步IO
IO的并发或者将多个读取连续内存的IO合并
### 刷新邻接页
刷新脏页时会检测邻接页，若是脏页一并刷新，减少IO次数  

## 索引与算法
innodb支持三种索引 : B+树索引 哈希索引 全文索引
> B+树中的B代表balance

B+树索引只是查找数据所在的页，读取页后再进行查找。  
插入 : B+树子节点满的时候，并不一定会拆分，考虑到拆分的开销，如果左右节点并不慢，会进行旋转，直观点就是数据平移以放下新的数据。   
删除 : 使用填充因子(>=0.5),节点填充度如果小于填充因子进行相应合并  
&nbsp;  
聚集索引和辅助索引.  
聚集索引 : 聚集索引表记录的排列顺序和索引的排列顺序一致,叶子节点中存储的就是行数据，行数据在物理储器中的真实地址就是按照主键索引树形成的顺序进行排列的，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放.因为在物理内存中的顺序只能有一种，所以聚集索引在一个表中只能有一个。  
辅助索引 : 非聚集索引制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致（在逻辑上数据是按顺序排存放的，但是物理上在真实的存储器中是散列存放的），两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。  
辅助索引先根据索引找到主键再根据主键到聚集索引里查询数据。  
B+树的分裂 : 考虑一个自增的索引，此种情况下分裂左侧的子节点会有空间浪费，新数据只会插入右边。为了改善此种情况，innoDB决定若往同一方向进行分裂的数量为5，且此时定位的记录(将插入的记录的前一个节点)后还有三个节点，则将定位后移3，自增索引往往分裂右边只有新插入记录。  

## MySQL基础架构-查询语句的运行
MySQL分为Server层和存储引擎层。客户端与连接器(管理连接，权限验证)建立连接后，交给分析器(词法分析，语法分析)，如果上面两个阶段中在查询缓存中命中，则直接返回结果(**MySQL8.0后查询缓存被删除**)，之后交予优化器进行执行计划生成和选择索引，再由执行器根据表的定义去使用引擎提供的接口后返回结果。

## MySQL更新
redo log(重做日志)和binlog(归档日志)
记录更新时，写入redo后更新内存，之后在写回磁盘。通过redo log具有了crash-safe能力  
redo是innodb特有的日志，Server层有binlog  
1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。
2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。
3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

**两阶段提交**  
为了防止redo和binlog之间发生的crash导致的不统一，更新后先写入redo，此时redo为prepare状态后写入binlog最后提交redo，变成commit状态  

**事务隔离**  
隔离的四个级别  
1. 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
2. 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
3. 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
4. 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。  
数据库会建立视图，访问的时候会以视图的结果为准。  
每次更新会增加一条回滚记录，通过回滚实现MVCC。  
当系统里没有比回滚日志更早的视图时就会删除回滚日志。  

**索引介绍**  
1. 哈希表，很快但只适用于等值查询，范围查询时效率很低  
2. 有序数组，二分法查询，但是更改时很麻烦，会移动很多元素  
3. 搜索树，innodb使用B+树  

**innodb的索引**  
分为主键索引(聚簇索引)和非主键索引(二级索引)，普通索引的使用需要查询对应主键后回表  
一般情况下自增主键会好一些  
**覆盖索引**就是把单列的非主键索引修改为多字段的联合索引,在一棵索引树上就找到了想要的数据, 不需要回表  
这个现象,称之索引覆盖.  
B+树使用**最左前缀原则**来定位记录，所以建立联合索引的时候优先考虑少维护索引的字段顺序  
**索引下推优化**在联合索引遍历过程中过滤掉不满足的记录，减少回表次数  
## MySQL的锁
MySQL的锁大致分为全局锁、表级锁和行锁  
**全局锁**就是对整个数据库加锁，全局锁的典型使用场景是，做全库逻辑备份，备份时全局处于只读状态  
**表级锁**有表锁和元数据锁两种。表锁一般是在数据库引擎不支持行锁的时候才会被用到的。而MDL不需要显式使用，在访问一个表的时候会被自动加上，读锁共享，写锁与读、写锁互斥。  
**行锁**是引擎自己实现的。在innodb中，行锁在需要时加上，在事务结束后才会释放(两阶段锁协议)。**需要注意死锁检测**

**MySQL里的视图**有两个概念:
1. 一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view ... ，而它的查询方法与表一样。
2. 另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。

**MVCC中快照的实现** : innodb中每个事务都有唯一的事务ID，而每行数据更新时都会把事务ID赋给此数据版本的事务ID，即row trx_id，即数据库中的一行记录可能有多个版本  

更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。

普通索引和唯一索引的查询效率基本一致(虽然普通索引会往下读取，但因为按页读取，一页有较多key)，更新语句后如果数据在内存中直接更新，否则存到change buffer中，等到下一次读到包含此数据的页后merge  
只有普通索引可以使用change buffer，因为唯一索引更新时要进行唯一性检测所以要将数据读入  

给字符串字段加索引需要考虑前缀索引，可以使用reverse字符串或哈希函数来增加区分度，但只支持等值查询。  

MySQL表包含两部分 : 表结构定义和数据。innodb_file_per_table设置为ON，可以使表数据在单独的文件中。  
删除表的数据只是将记录或者页标记为可复用，并不会释放内存，需要重建表才可以减少内存浪费  

orderby使用分配的sort_buffer，先读入数据再进行根据key排序。
如果数据太大，就会借用磁盘中的临时文件。如果行太长，能读取的数据太少，就只将合适的列数据读入，最后根据主键取其余的列返回客户端  

对索引字段做函数操作，会破坏索引的有序性，优化器会放弃走树搜索功能。  
MySQL中数字和字符串比较时会将字符串转换成数字  
不同表之间的字符编码不一致会导致索引失效  

幻读 : 针对插入新数据产生的数据不一致，要用间隙锁来应对  

**乐观锁和悲观锁** : 乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。

乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。  
悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。  
**乐观锁**的实现方式主要有两种：CAS(compare and swap, 利用cpu中的原子操作)机制和版本号机制(使用额外变量标记改变，此处为一个'版本号')  
CAS操作包括了3个操作数：
1. 需要读写的内存位置(V)
2. 进行比较的预期值(A)
3. 拟写入的新值(B)  

CAS操作逻辑如下：如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。许多CAS的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。  
CAS的缺点: 1、ABA问题，即两个线程一个先读取内存中的A，另一个再改为B，此时依然可以更改，可以同时引入版本号解决。2、高竞争下的开销，CAS放弃太多次会增加开销可以引入退出机制。3、功能有限，只能保证单个变量的原子性  
**悲观锁**加锁即可。